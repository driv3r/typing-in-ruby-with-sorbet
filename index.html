<!doctype html>
  <head lang="en">
    <meta charset="utf-8">
    <title>Typing in Ruby with Sorbet</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/dracula.min.css" id="theme"/>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/monokai.min.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown >
          <script type="text/template">
            ---

            ## Typing in Ruby with Sorbet

            ---

            ### Leszek Zalewski
            #### Staff Developer at Shopify

            ---

            ### Agenda

            - State of Types in Ruby
            - Sorbet basics <!-- .element: class="fragment" -->
            - Modeling with types <!-- .element: class="fragment" -->

            ---

            ### RBS: Ruby Signatures

            1. Ruby like language to describe the structure of Ruby programs
            2. Signatures live in separate file(s) <!-- .element: class="fragment" -->
            3. Built into Ruby <!-- .element: class="fragment" -->
            4. Not a Ruby <!-- .element: class="fragment" -->

            ---

            ### RBS: Example

            ```rb
            class User                      # defined in lib/user.rb
              attr_reader :login, :email
              def initialize(login, email)
                @login = login
                @email = email
              end
            end
            ```

            ```rb
            class User                      # defined in sig/user.rbs
              attr_reader login: String
              attr_reader email: String

              def initialize: (String login, String email) -> void
            end
            ```

            ---

            ### RBS: Tools

            1. `rbs` includes commands for inspecting defined types
            2. `typeprof` type analysis for existing codebases, i.e. helps discover and prototype type definitions
            3. `steep` will verify that codebase adheres to the type definitions

            ---

            ### RBS: Example

            ```sh
            $> steep init
            ```

            ```rb
            class Validate        # lib/validate.rb
              def self.check!
                User.new(1, 2.0)
              end
            end
            ```

            ```sh
            $> steep check
            ```

            ---

            ### RBS: Example

            ![Found failure in validate class](images/steep-01.png)

            ---

            ### RBS: Summary

            Pros:
            - Built into Ruby (though as a gem) <!-- .element: class="fragment" -->
            - Decoupled design: provides structured data for other tools to use, i.e. steep, typeprof, sorbet <!-- .element: class="fragment" -->

            Cons: <!-- .element: class="fragment" -->
            - Have to define signatures in separate files, this can cause definitions to go out of date quite fast <!-- .element: class="fragment" -->
            - Language for signatures is not pure ruby <!-- .element: class="fragment" -->

            ---

            ### Sorbet

            - Whole package for defining, validating and checking type signatures
            - Provides pure Ruby DSL for defining type signatures <!-- .element: class="fragment" -->
            - Allows definitions to live in a separate files (RBI) as well as inline next to the code <!-- .element: class="fragment" -->
            - Able to use RBS files <!-- .element: class="fragment" -->
            - More feature rich (i.e. typed enums, exhaustiveness checking, etc.) <!-- .element: class="fragment" -->

            ---

            ### Sorbet vs RBS

            RBS is just a "language" to define types, Sorbet is a whole toolset.

            ---

            #### Sorbet basics: Add to project

            ```rb [1|2|3]
            gem "sorbet", group: :development
            gem "sorbet-runtime"
            gem "tapioca", require: false, group: :development
            ```

            ---

            #### Sorbet basics: Initialize

            ```sh
            $> bundle exec tapioca init
            # This will take some time, and you will end up with new `sorbet` folder
            ├── config             # Default options to be passed to Sorbet on every run
            └── rbi/
              ├── annotations/     # Type definitions pulled from the rbi-central repository
              ├── gems/            # Autogenerated type definitions for your gems
              └── todo.rbi         # Constants which were still missing after RBI generation
            └── tapioca/
              ├── config.yml       # Default options to be passed to Tapioca
              └── require.rb       # A file where you can make requires from gems that might be needed for gem RBI generation
            ```

            ---

            #### Sorbet basics: Verify installation

            ```sh
            $> bundle exec srb tc
            No errors! Great job.
            ```

            ---

            #### Sorbet basics: Add annotations

            ```rb [1|4|6-7|9-10|12-16|1-17]
            # typed: strict

            class User
              extend T::Sig

              sig { returns(String) }
              attr_reader :login

              sig { returns(String) }
              attr_reader :password

              sig { params(login: String, password: String).void }
              def initialize(login, password)
                @login = login
                @password = password
              end
            end
            ```

            ---

            #### Sorbet basics: Test

            ```rb [1|7|9|11|1-14]
            # typed: strict

            require_relative "user"

            class Validate
              class << self
                extend T::Sig

                sig { void }
                def check!
                  User.new(1, 2.0)
                end
              end
            end
            ```

            ---

            #### Sorbet basics: Test

            ```sh
            $> bundle exec srb tc
            ```

            ![sorbet validation](images/srb-01.png)

            ---

            #### Sorbet basics: Classes are types

            ```rb [8-9|11-17|13|14|15|1-23]
            # typed: strict

            require_relative "user"

            class More
              extend T::Sig

              sig { returns(User) }
              attr_accessor :user

              sig {
                params(
                  user: User,
                  verify: T::Boolean,
                  scope: T.nilable(String)
                ).void
              }
              def initialize(user:, verify: false, scope: nil)
                @user = user
                @verify = verify
                @scope = scope
              end
            end
            ```

            ---

            #### Sorbet basics: Test

            ```rb
            m = More.new(User.new("foo", "bar"))
            ```

            ![check for required kwargs](images/srb-03.png)     <!-- .element: class="fragment" -->
            ![it's not always smart though](images/srb-04.png)  <!-- .element: class="fragment" -->

            ---

            #### Sorbet basics: Test

            ```rb
            m = More.new(user: User.new("foo", "bar"))
            m.user = "baz"
            ```

            ![check for writer](images/srb-05.png)              <!-- .element: class="fragment" -->

            ---

            ### What we have so far

            - Type annotations that describe the code
            - Act as documentation
            - With CI and `srb tc` we could verify that nothing breaks our contracts

            ---

            #### Reduce defensive programming

            Instead of

            ```rb [2-4|8-9]
            def check!(user:)
              unless user.is_a?(User)
                raise ArgumentError, "need user, got: #{user.inspect}"
              end
              # ...
            end

            expect { validation.check!(user: nil) }.to
              raise_error(ArgumentError)
            ```

            ---

            #### Reduce defensive programming

            We could rely on sorbet and just have

            ```rb
            sig { params(user: User) }
            def check!(user:)
              # ...
            end
            ```

            ---

            #### Model with types: Enums

            ```rb
            class API
              ACTIONS = [:get, :list, :create, :update, :delete]

              def run(action:)
                unless ACTIONS.include?(action)
                  raise ArgumentError
                end

                # ...
              end
            end
            ```

            ---

            #### Model with types: Enums

            ```rb
            class API
              class Actions < T::Enum
                enums do
                  Get = new
                  List = new
                  Create = new
                  Update = new
                  Delete = new
                end
              end

              sig { params(action: API::Actions).returns(Response) }
              def run(action:)
                # ...
              end
            end
            ```

            ---

            #### Model with types: Enums

            ```rb [1-2|4-6]
            # Using Enums
            API.run(action: API::Actions::List)

            # Serializing
            puts "Action: #{API::Actions::List.serialize}"
            # => Action: list
            ```

            ---

            #### Model with types: Structs

            ```rb
            class Response < T::Struct
              prop :code, Integer
              prop :message, String
              prop :users, T::Array[User], default: []
            end
            ```

            ---

            #### Model with types: Exhaustiveness checks

            ```rb
            sig { params(x: T.any(A, B)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              end
            end
            ```

            ---

            #### Model with types: Exhaustiveness checks

            ```rb [1]
            sig { params(x: T.any(A, B, C)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              end
            end
            ```

            ---

            #### Model with types: Exhaustiveness checks

            ```rb [8-10]
            sig { params(x: T.any(A, B, C)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              else
                T.absurd(x)
              end
            end
            ```

            ---

            #### Model with types: Type aliases

            ```rb [1-3|5-7]
            # Simple aliases improving readability and documentation
            ID = T.type_alias { Integer }
            UUID = T.type_alias { String }

            # Type Unions
            Boolean = T.type_alias { T.any(TrueClass, FalseClass) }
            User = T.type_alias { T.any(Customer, Manager, Admin, Root) }
            ```

            ---

            ## So where are we?

            ---

            ### Pros of using types

            - better documentaion & maintenance <!-- .element: class="fragment" -->
            - less tests to write <!-- .element: class="fragment" -->
            - less defensive programming <!-- .element: class="fragment" -->
            - less bugs <!-- .element: class="fragment" -->
            - changes approach to coding for better <!-- .element: class="fragment" -->

            ---

            ### Cons of introducing types

            - more boilerplate up front <!-- .element: class="fragment" -->
            - its gradual typing, so benefits come only with more coverage <!-- .element: class="fragment" -->
            - there are still quirks and rough edges around the tooling <!-- .element: class="fragment" -->
            - it's doesn't feel native, it's a DSL <!-- .element: class="fragment" -->
            - performance penality when checking types during runtime <!-- .element: class="fragment" -->

            ---

            ## Should you start using types?

            It depends :) <!-- .element: class="fragment" -->

            ---

            ## Questions?

            - https://github.com/ruby/rbs
            - https://github.com/ruby/typeprof
            - https://github.com/soutaro/steep
            - https://sorbet.org/
            - https://github.com/Shopify/tapioca

          </script>
        </section>

      </div>
    </div>

    <!-- Setup Reveal.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        plugins: [ RevealMarkdown, RevealNotes, RevealHighlight ],
        slideNumber: true,
        autoAnimate: false,
        transition: 'none'
      });
    </script>

  </body>
</html>
