<!doctype html>
  <head lang="en">
    <meta charset="utf-8">
    <title>Typing in Ruby with Sorbet</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/theme/dracula.min.css" id="theme"/>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/base16/monokai.min.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          ## Typing in Ruby with Sorbet

          ---
          ### Leszek Zalewski
          #### Staff Developer at Shopify

          ---

          ### Agenda

          - State of Types in Ruby
          - Sorbet basics
          - Modeling with types

          Note:
          We will discuss:
          - What's the current state of typing ecosystem in Ruby
          - We will quickly go through basics in Sorbet
          - We will see how we could start modeling with types
          - And the good, bad and ugly parts about typing in Ruby

          ---

          #### State of Types in Ruby
          ### RBS: Ruby Signatures

          1. Ruby like language to describe the structure of Ruby programs
          2. Signatures live in separate file(s)
          3. Built into Ruby
          4. Not a Ruby

          ---

          #### State of Types in Ruby
          ### RBS: Example

          ```rb
          class User                      # defined in lib/user.rb
            attr_reader :login, :email
            def initialize(login, email)
              @login = login
              @email = email
            end
          end

          class User                      # defined in sig/user.rbs
            attr_reader login: String
            attr_reader email: String

            def initialize: (String login, String email) -> void
          end

          ```

          ---
          #### State of Types in Ruby
          ### RBS: Tools

          1. `rbs` includes commands for inspecting defined types
          2. `typeprof` type analysis for existing codebases, i.e. helps discover and prototype type definitions
          3. `steep` will verify that codebase adheres to the type definitions

          ---

          #### State of Types in Ruby
          ### RBS: Example

          ```sh
          $> steep init
          ```

          ```rb
          class Validate        # lib/validate.rb
            def self.check!
              User.new(1, 2.0)
            end
          end
          ```

          ```sh
          $> steep check
          ```

          ---

          #### State of Types in Ruby
          ### RBS: Example

          ![Found failure in validate class](images/steep-01.png)

          ---

          #### State of Types in Ruby
          ### RBS: Summary

          Pros:
          - Built into Ruby (though as a gem)
          - Decoupled design: provides structured data for other tools to use, i.e. steep, typeprof, sorbet

          Cons:
          - Have to define signatures in separate files, this can cause definitions to go out of date quite fast,
          - Language for signatures is not pure ruby

          ---

          #### State of Types in Ruby
          ### Sorbet

          - Whole package for defining, validating and checking type signatures
          - Provides pure Ruby DSL for defining type signatures
          - Allows definitions to live in a separate files (RBI) as well as inline next to the code
          - Able to use RBS files
          - More feature rich (i.e. typed enums, exhaustiveness checking, etc.)

          ---

          #### State of Types in Ruby
          ### Sorbet vs RBS

          RBS is just a "language", Sorbet extends it.

          ---
          #### Sorbet basics: add to project

          ```rb
          gem "sorbet", group: :development
          gem "sorbet-runtime"
          gem "tapioca", require: false, group: :development
          ```

          Notes:
          - `sorbet` static type checker which runs as CLI
          - `sorbet-runtime` provides syntax for type annotations and some type friendly data structures
          - `tapioca` generates RBI files to allow Sorbet to easily work with gems and metaprogramming

          ---

          #### Sorbet basics: Initialize

          ```sh
          $> bundle exec tapioca init
          # This will take some time, and you will end up with new `sorbet` folder
          ├── config             # Default options to be passed to Sorbet on every run
          └── rbi/
            ├── annotations/     # Type definitions pulled from the rbi-central repository
            ├── gems/            # Autogenerated type definitions for your gems
            └── todo.rbi         # Constants which were still missing after RBI generation
          └── tapioca/
            ├── config.yml       # Default options to be passed to Tapioca
            └── require.rb       # A file where you can make requires from gems that might be needed for gem RBI generation
          ```

          ---

          #### Sorbet basics: Verify installation

          ```sh
          $> bundle exec srb tc
          No errors! Great job.
          ```

          ---

          #### Sorbet basics: Add annotations

          ```rb [1|4|6-7|9-10|12-16|1-17]
          # typed: strict

          class User
            extend T::Sig

            sig { returns(String) }
            attr_reader :login

            sig { returns(String) }
            attr_reader :password

            sig { params(login: String, password: String).void }
            def initialize(login, password)
              @login = login
              @password = password
            end
          end
          ```

          ---

          #### Sorbet basics: Test

          ```rb [1|7|9|11|1-14]
          # typed: strict

          require_relative "user"

          class Validate
            class << self
              extend T::Sig

              sig { void }
              def check!
                User.new(1, 2.0)
              end
            end
          end
          ```

          ---

          #### Sorbet basics: Test

          ```sh
          $> bundle exec srb tc
          ```

          ![sorbet validation](images/srb-01.png)

          ---

          #### Sorbet basics: Classes are types

          ```rb [8-9|11-17|13|14|15|1-23]
          # typed: strict

          require_relative "user"

          class More
            extend T::Sig

            sig { returns(User) }
            attr_accessor :user

            sig {
              params(
                user: User,
                verify: T::Boolean,
                scope: T.nilable(String)
              ).void
            }
            def initialize(user:, verify: false, scope: nil)
              @user = user
              @verify = verify
              @scope = scope
            end
          end
          ```
        </section>

        <section data-markdown >
          <script type="text/template">
            #### Sorbet basics: Test

            ```rb
            m = More.new(User.new("foo", "bar"))
            ```

            ![check for required kwargs](images/srb-03.png)     <!-- .element: class="fragment" -->
            ![it's not always smart though](images/srb-04.png)  <!-- .element: class="fragment" -->

            ---

            #### Sorbet basics: Test

            ```rb
            m = More.new(user: User.new("foo", "bar"))
            m.user = "baz"
            ```

            ![check for writer](images/srb-05.png)              <!-- .element: class="fragment" -->

            ---

            ### What we have so far

            - Type annotations that describe the code
            - Act as documentation
            - With CI and `srb tc` we could verify that nothing breaks our contracts

            ---

            #### Reduce defensive programming

            Instead of

            ```rb [2-4|8-9]
            def check!(user:)
              unless user.is_a?(User)
                raise ArgumentError, "need user, got: #{user.inspect}"
              end
              # ...
            end

            expect { validation.check!(user: nil) }.to
              raise_error(ArgumentError)
            ```

            ---

            #### Reduce defensive programming

            We could rely on sorbet and just have

            ```rb
            sig { params(user: User) }
            def check!(user:)
              # ...
            end
            ```

            ---

            #### Model with types

            ```rb
            class API
              ACTIONS = [:get, :list, :create, :update, :delete]

              def run(action:)
                unless ACTIONS.include?(action)
                  raise ArgumentError
                end

                # ...
              end
            end
            ```

            ---

            #### Model with types: Enums

            ```rb
            class API
              class Actions < T::Enum
                enums do
                  Get = new
                  List = new
                  Create = new
                  Update = new
                  Delete = new
                end
              end

              sig { params(action: API::Actions).returns(Response) }
              def run(action:)
                # ...
              end
            end
            ```

            ---

            #### Model with types: Structs

            ```rb
            class Response < T::Struct
              prop :code, Integer
              prop :message, String
              prop :users, T::Array[User], default: []
            end
            ```

            ---

            #### Model with types: Exhaustiveness checks

            ```rb
            sig { params(x: T.any(A, B)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              end
            end
            ```

            ---

            #### Model with types: Exhaustiveness checks

            ```rb [1]
            sig { params(x: T.any(A, B, C)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              end
            end
            ```
            ---

            #### Model with types: Exhaustiveness checks

            ```rb
            sig { params(x: T.any(A, B, C)).void }
            def foo(x)
              case x
              when A
                # ...
              when B
                # ...
              else
                T.absurd(x)
              end
            end
            ```

            ---

            ### So where are we?
            #### Pros of using types

            - better documentaion & maintenance
            - less tests to write
            - less defensive programming
            - less bugs
            - changes approach to coding for better

            ---

            ### So where are we?
            #### Cons of introducing types

            - more boilerplate up front
            - its gradual typing, so benefits come only with more coverage
            - there are still quirks and rough edges around the tooling
            - it's doesn't feel `native`, it's a DSL
            - performance penality when checking types during runtime

            ---

            ## Questions?

            - https://github.com/ruby/rbs
            - https://github.com/soutaro/steep
            - https://sorbet.org/
            - https://github.com/Shopify/tapioca

          </script>
        </section>

      </div>
    </div>

    <!-- Setup Reveal.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.5.0/plugin/highlight/highlight.min.js"></script>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        plugins: [ RevealMarkdown, RevealNotes, RevealHighlight ],
        slideNumber: true,
        autoAnimate: false,
        transition: 'none'
      });
    </script>

  </body>
</html>
